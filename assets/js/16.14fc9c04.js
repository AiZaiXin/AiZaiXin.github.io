(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{377:function(e,n,t){"use strict";t.r(n);var s=t(45),a=Object(s.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"springboot统一接口返回和全局异常处理"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#springboot统一接口返回和全局异常处理"}},[e._v("#")]),e._v(" SpringBoot统一接口返回和全局异常处理")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("现在大多数公司项目框架，基本都是属于前后端分离模式，这种模式会涉及到一个前后端对接问题，无论是对前端或者是后台服务，维护一套完善且规范的接口是非常有必要的，这样不仅能够提高对接效率，也可以让我的代码看起来更加简洁优雅。\n修改前后最大的区别是我们不用在每个接口单独捕获异常，也不用在每个接口都要组装一遍返回参数\n")])])]),t("h2",{attrs:{id:"springboot不使用统一返回格式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#springboot不使用统一返回格式"}},[e._v("#")]),e._v(" SpringBoot不使用统一返回格式")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('默认情况下，SpringBoot会有如下三种返回情况。\n1、字符串\n```\n@GetMapping("/getUserName")\npublic String getUserName(){\n    return "asd";\n}\n```\n2、实体类\n```\n@GetMapping("/getUserName")\npublic User getUserName(){\n    return new User("asd",18,"男");\n}\n```\n3、异常返回\n```\n@GetMapping("/getUserName")\npublic static String getUserName(){\n    HashMap hashMap = Maps.newHashMap();\n    return hashMap.get(0).toString();\n}\n```\n')])])]),t("h3",{attrs:{id:"基础用法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#基础用法"}},[e._v("#")]),e._v(" 基础用法")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('项目中最常见到的是封装一个工具类，类中定义需要返回的字段信息，把需要返回前端的接口信息，通过该类进行封装，这样就可以解决返回格式不统一的现象了。\n1、定义参数\n    code： 状态码，后台可以维护一套统一的状态码；\n    message： 描述信息，接口调用成功/失败的提示信息；\n    data： 返回数据。\n2、代码实现\n    ```\n    public class Result<T> {\n        private int code;\n        private String message;\n        private T data;\n        public Result() {}\n        public Result(int code, String message) {\n            this.code = code;\n            this.message = message;\n        }\n        /**\n         * 成功\n         */\n        public static <T> Result<T> success(T data) {\n            Result<T> result = new Result<T>();\n            result.setCode(ResultMsgEnum.SUCCESS.getCode());\n            result.setMessage(ResultMsgEnum.SUCCESS.getMessage());\n            result.setData(data);\n            return result;\n        }\n        /**\n         * 失败\n         */\n        public static <T> Result<T> error(int code, String message) {\n            return new Result(code, message);\n        }\n    }\n    ```\n    定义返回状态码\n    ```\n    public enum ResultMsgEnum {\n        SUCCESS(0, "成功"),\n        FAIL(-1, "失败"),\n        AUTH_ERROR(502, "授权失败!"),\n        SERVER_BUSY(503, "服务器正忙，请稍后再试!"),\n        DATABASE_OPERATION_FAILED(504, "数据库操作失败");\n        private int code;\n        private String message;\n    ​\n        ResultMsgEnum(int code, String message) {\n            this.code = code;\n            this.message = message;\n        }\n        public int getCode() {\n            return this.code;\n        }\n        \n        public String getMessage() {\n            return this.message;\n        }\n    }\n    ```\n    使用\n    ```\n    @GetMapping("/getUserName")\n    public Result getUserName(){\n        return Result.success("huage");\n    }\n    ```\n    调用结果如下，可以看到是我们在Result中定义的参数类型\n    ```\n    {\n        "code": 0,\n        "message": "成功",\n        "data": "huage"\n    }\n    ```\n')])])]),t("h2",{attrs:{id:"_2-2"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2"}},[e._v("#")]),e._v(" 2.2")]),e._v(" "),t("blockquote",[t("p",[e._v("引用部分")])])])}),[],!1,null,null,null);n.default=a.exports}}]);